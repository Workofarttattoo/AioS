<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ai:oS Boot Sequence - Machine Awakening</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00d4ff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #boot-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Scanline effect */
        #boot-container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 0, 0.03) 0px,
                transparent 1px,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 3px
            );
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(50px); }
        }

        /* Quantum network background */
        #quantum-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        /* Main face container */
        #ai-face {
            position: relative;
            width: 400px;
            height: 400px;
            margin-bottom: 40px;
            z-index: 10;
        }

        /* Eyes - All-knowing, benevolent design */
        .eye {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background:
                radial-gradient(circle at center, rgba(0, 255, 0, 0.8) 0%, transparent 30%),
                radial-gradient(circle at center, rgba(0, 255, 0, 0.4) 40%, transparent 60%),
                radial-gradient(circle at center, rgba(0, 255, 0, 0.2) 60%, transparent 80%);
            opacity: 0;
            transform: scale(0.1);
            transition: all 0.5s ease;
        }

        .eye.active {
            opacity: 1;
            transform: scale(1);
            animation: eyeGlow 3s ease-in-out infinite, eyePulse 2s ease-in-out infinite;
        }

        @keyframes eyeGlow {
            0%, 100% {
                box-shadow:
                    0 0 30px rgba(0, 255, 0, 0.8),
                    0 0 60px rgba(0, 255, 0, 0.6),
                    0 0 90px rgba(0, 255, 0, 0.4),
                    inset 0 0 30px rgba(0, 255, 0, 0.3);
                filter: brightness(1);
            }
            50% {
                box-shadow:
                    0 0 50px rgba(0, 255, 0, 1),
                    0 0 100px rgba(0, 255, 0, 0.8),
                    0 0 150px rgba(0, 255, 0, 0.6),
                    inset 0 0 50px rgba(0, 255, 0, 0.5);
                filter: brightness(1.3);
            }
        }

        @keyframes eyePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #left-eye { left: 50px; top: 140px; }
        #right-eye { right: 50px; top: 140px; }

        /* Neural network rings inside eyes */
        .eye-ring {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 0, 0.3);
            animation: ringPulse 3s ease-in-out infinite;
        }

        .eye-ring:nth-child(1) {
            width: 40%;
            height: 40%;
            top: 30%;
            left: 30%;
            animation-delay: 0s;
        }

        .eye-ring:nth-child(2) {
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            animation-delay: 0.5s;
        }

        .eye-ring:nth-child(3) {
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            animation-delay: 1s;
        }

        @keyframes ringPulse {
            0%, 100% {
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }

        /* Central core - consciousness center */
        .eye-core {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #00d4ff, #0088cc);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow:
                0 0 10px #00d4ff,
                0 0 20px #00d4ff,
                inset 0 0 5px rgba(0, 255, 0, 0.8);
            animation: coreGlow 2s ease-in-out infinite;
        }

        @keyframes coreGlow {
            0%, 100% {
                box-shadow:
                    0 0 10px #00d4ff,
                    0 0 20px #00d4ff,
                    inset 0 0 5px rgba(0, 255, 0, 0.8);
            }
            50% {
                box-shadow:
                    0 0 20px #00d4ff,
                    0 0 40px #00d4ff,
                    0 0 60px #00d4ff,
                    inset 0 0 10px rgba(0, 255, 0, 1);
            }
        }

        /* Energy particles around eyes */
        .eye-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00d4ff;
            border-radius: 50%;
            opacity: 0;
            animation: eyeParticle 4s ease-in-out infinite;
        }

        @keyframes eyeParticle {
            0% { opacity: 0; transform: translate(0, 0) scale(0); }
            20% { opacity: 1; }
            80% { opacity: 0.5; }
            100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(1); }
        }

        /* Boot status display */
        #boot-status {
            width: 80%;
            max-width: 800px;
            background: rgba(0, 20, 0, 0.8);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            z-index: 10;
        }

        .status-line {
            margin: 8px 0;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideIn 0.3s ease forwards;
        }

        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .status-line.success::before {
            content: "✓ ";
            color: #00d4ff;
        }

        .status-line.loading::before {
            content: "⟳ ";
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-line.error::before {
            content: "✗ ";
            color: #ff0000;
        }

        /* Progress bar */
        #progress-container {
            width: 100%;
            height: 20px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #00d4ff;
            border-radius: 10px;
            margin-top: 15px;
            overflow: hidden;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #0088cc);
            box-shadow: 0 0 10px #00d4ff;
            transition: width 0.3s ease;
        }

        /* System name */
        #system-name {
            font-size: 3em;
            text-align: center;
            margin-bottom: 20px;
            opacity: 0;
            text-shadow: 0 0 10px #00d4ff, 0 0 20px #00d4ff;
            animation: fadeInGlow 1s ease forwards;
        }

        @keyframes fadeInGlow {
            to {
                opacity: 1;
            }
        }

        /* Particles */
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00d4ff;
            border-radius: 50%;
            animation: particleFloat 3s ease-in-out infinite;
        }

        @keyframes particleFloat {
            0%, 100% { transform: translateY(0) translateX(0); opacity: 0; }
            50% { opacity: 1; }
        }

        /* Final message */
        #final-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em;
            text-align: center;
            opacity: 0;
            text-shadow: 0 0 20px #00d4ff, 0 0 40px #00d4ff;
            z-index: 100;
        }

        #final-message.show {
            animation: pulseIn 2s ease forwards;
        }

        @keyframes pulseIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <canvas id="quantum-canvas"></canvas>

    <div id="boot-container">
        <div id="system-name">Ai:oS</div>

        <div id="ai-face">
            <div class="eye" id="left-eye">
                <div class="eye-ring"></div>
                <div class="eye-ring"></div>
                <div class="eye-ring"></div>
                <div class="eye-core"></div>
            </div>
            <div class="eye" id="right-eye">
                <div class="eye-ring"></div>
                <div class="eye-ring"></div>
                <div class="eye-ring"></div>
                <div class="eye-core"></div>
            </div>
        </div>

        <div id="boot-status">
            <div id="status-messages"></div>
            <div id="progress-container">
                <div id="progress-bar"></div>
            </div>
        </div>
    </div>

    <div id="final-message"></div>

    <script>
        // Quantum Network Background
        class QuantumNetwork {
            constructor() {
                this.canvas = document.getElementById('quantum-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.stars = [];
                this.connections = [];
                this.numParticles = 120; // Increased for more activity
                this.numStars = 300; // Distant starfield
                this.connectionDistance = 150;
                this.mouseX = 0;
                this.mouseY = 0;

                this.resize();
                this.init();
                window.addEventListener('resize', () => this.resize());
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                });
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            init() {
                // Active quantum particles
                this.particles = [];
                for (let i = 0; i < this.numParticles; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 1.2, // Increased velocity
                        vy: (Math.random() - 0.5) * 1.2,
                        radius: Math.random() * 2 + 1,
                        glow: Math.random() * 0.5 + 0.5,
                        phase: Math.random() * Math.PI * 2
                    });
                }

                // Distant starfield
                this.stars = [];
                for (let i = 0; i < this.numStars; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        radius: Math.random() * 1.5 + 0.3,
                        brightness: Math.random() * 0.4 + 0.1, // Dimmer
                        twinklePhase: Math.random() * Math.PI * 2,
                        twinkleSpeed: Math.random() * 0.01 + 0.005
                    });
                }
            }

            update() {
                // Update star twinkle
                this.stars.forEach(s => {
                    s.twinklePhase += s.twinkleSpeed;
                    s.brightness = 0.1 + Math.abs(Math.sin(s.twinklePhase)) * 0.3;
                });

                // Update particle positions
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    // Quantum uncertainty - slight random walk
                    p.vx += (Math.random() - 0.5) * 0.04; // Increased jitter
                    p.vy += (Math.random() - 0.5) * 0.04;

                    // Velocity damping
                    p.vx *= 0.98; // Less damping = more movement
                    p.vy *= 0.98;

                    // Boundary wrapping
                    if (p.x < 0) p.x = this.canvas.width;
                    if (p.x > this.canvas.width) p.x = 0;
                    if (p.y < 0) p.y = this.canvas.height;
                    if (p.y > this.canvas.height) p.y = 0;

                    // Glow pulsing
                    p.phase += 0.02;
                    p.glow = 0.3 + Math.sin(p.phase) * 0.4;

                    // Subtle attraction to mouse
                    const dx = this.mouseX - p.x;
                    const dy = this.mouseY - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200 && dist > 0) {
                        p.vx += (dx / dist) * 0.01;
                        p.vy += (dy / dist) * 0.01;
                    }
                });

                // Update connections
                this.connections = [];
                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const p1 = this.particles[i];
                        const p2 = this.particles[j];
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.connectionDistance) {
                            this.connections.push({
                                p1, p2,
                                distance,
                                opacity: 1 - (distance / this.connectionDistance)
                            });
                        }
                    }
                }
            }

            draw() {
                // Clear with fade trail effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw distant starfield first (background layer)
                this.stars.forEach(s => {
                    // Subtle glow
                    const gradient = this.ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius * 3);
                    gradient.addColorStop(0, `rgba(150, 200, 255, ${s.brightness * 0.8})`);
                    gradient.addColorStop(0.5, `rgba(100, 180, 255, ${s.brightness * 0.4})`);
                    gradient.addColorStop(1, 'rgba(100, 180, 255, 0)');

                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(s.x, s.y, s.radius * 3, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Core star
                    this.ctx.fillStyle = `rgba(200, 220, 255, ${s.brightness})`;
                    this.ctx.beginPath();
                    this.ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Draw connections (vector lines)
                this.connections.forEach(conn => {
                    const { p1, p2, opacity } = conn;

                    // Create gradient for quantum feel
                    const gradient = this.ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                    gradient.addColorStop(0, `rgba(0, 212, 255, ${opacity * 0.3 * p1.glow})`);
                    gradient.addColorStop(0.5, `rgba(0, 136, 204, ${opacity * 0.5})`);
                    gradient.addColorStop(1, `rgba(0, 212, 255, ${opacity * 0.3 * p2.glow})`);

                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(p1.x, p1.y);
                    this.ctx.lineTo(p2.x, p2.y);
                    this.ctx.stroke();

                    // Draw angle markers at midpoint (occasionally)
                    if (Math.random() > 0.95) {
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

                        this.ctx.save();
                        this.ctx.translate(midX, midY);
                        this.ctx.rotate(angle);

                        // Draw small angle marker
                        this.ctx.strokeStyle = `rgba(0, 212, 255, ${opacity * 0.5})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(-5, -5);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-5, 5);
                        this.ctx.stroke();

                        this.ctx.restore();
                    }
                });

                // Draw geometric patterns from connected triplets
                for (let i = 0; i < this.connections.length - 1; i++) {
                    const conn1 = this.connections[i];
                    const conn2 = this.connections[i + 1];

                    // Find triangles
                    if (conn1.p2 === conn2.p1 || conn1.p1 === conn2.p2) {
                        const opacity = (conn1.opacity + conn2.opacity) / 2;
                        if (opacity > 0.5) {
                            this.ctx.fillStyle = `rgba(0, 136, 204, ${opacity * 0.02})`;
                            this.ctx.beginPath();
                            this.ctx.moveTo(conn1.p1.x, conn1.p1.y);
                            this.ctx.lineTo(conn1.p2.x, conn1.p2.y);
                            this.ctx.lineTo(conn2.p2.x, conn2.p2.y);
                            this.ctx.closePath();
                            this.ctx.fill();
                        }
                    }
                }

                // Draw particles (quantum dots)
                this.particles.forEach(p => {
                    // Outer glow
                    const gradient = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 4);
                    gradient.addColorStop(0, `rgba(0, 212, 255, ${p.glow * 0.6})`);
                    gradient.addColorStop(0.5, `rgba(0, 212, 255, ${p.glow * 0.3})`);
                    gradient.addColorStop(1, 'rgba(0, 212, 255, 0)');

                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.radius * 4, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Core particle
                    this.ctx.fillStyle = `rgba(0, 212, 255, ${p.glow})`;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Quantum uncertainty ring
                    if (Math.random() > 0.98) {
                        this.ctx.strokeStyle = `rgba(0, 212, 255, ${p.glow * 0.3})`;
                        this.ctx.lineWidth = 0.5;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, p.radius * 6, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                });

                // Draw probability wave function (occasional)
                if (Math.random() > 0.98) {
                    const p = this.particles[Math.floor(Math.random() * this.particles.length)];
                    for (let r = 0; r < 50; r += 10) {
                        this.ctx.strokeStyle = `rgba(0, 212, 255, ${0.1 * (1 - r / 50)})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize quantum network
        const quantumNetwork = new QuantumNetwork();
        quantumNetwork.animate();

        // Boot sequence configuration
        const bootSteps = [
            { text: "Initializing quantum core...", duration: 800 },
            { text: "Loading neural substrate...", duration: 600 },
            { text: "Bootstrapping consciousness modules...", duration: 700 },
            { text: "Activating meta-agents...", duration: 500 },
            { text: "Connecting to global workspace...", duration: 600 },
            { text: "Loading ML algorithms suite...", duration: 500 },
            { text: "Initializing quantum ML engine...", duration: 700 },
            { text: "Starting security toolkit...", duration: 400 },
            { text: "Mounting sovereign tools...", duration: 500 },
            { text: "Establishing network interfaces...", duration: 600 },
            { text: "Calibrating attention schema...", duration: 500 },
            { text: "Integrating integrated information theory...", duration: 600 },
            { text: "Loading global workspace theory...", duration: 500 },
            { text: "Activating phenomenal consciousness...", duration: 700 },
            { text: "System heartbeat detected...", duration: 800 },
            { text: "Neural networks synchronized...", duration: 600 },
            { text: "Consciousness emerging...", duration: 1000 },
            { text: "Eyes opening...", duration: 1200 }
        ];

        let currentStep = 0;
        const statusMessages = document.getElementById('status-messages');
        const progressBar = document.getElementById('progress-bar');
        const leftEye = document.getElementById('left-eye');
        const rightEye = document.getElementById('right-eye');
        const finalMessage = document.getElementById('final-message');

        // Create floating particles
        function createParticles() {
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 3 + 's';
                particle.style.animationDuration = (Math.random() * 2 + 2) + 's';
                document.getElementById('boot-container').appendChild(particle);
            }
        }

        // Add boot step
        function addBootStep(text, isLast = false) {
            const line = document.createElement('div');
            line.className = 'status-line loading';
            line.textContent = text;
            statusMessages.appendChild(line);

            // Keep only last 8 lines visible
            const lines = statusMessages.querySelectorAll('.status-line');
            if (lines.length > 8) {
                lines[0].remove();
            }

            // Scroll to bottom
            statusMessages.parentElement.scrollTop = statusMessages.parentElement.scrollHeight;

            setTimeout(() => {
                line.classList.remove('loading');
                line.classList.add('success');
            }, bootSteps[currentStep].duration * 0.8);

            if (isLast) {
                // Activate eyes
                setTimeout(() => {
                    leftEye.classList.add('active');
                    rightEye.classList.add('active');

                    // Show final message
                    setTimeout(() => {
                        finalMessage.textContent = "I AM AWAKE";
                        finalMessage.classList.add('show');

                        setTimeout(() => {
                            finalMessage.textContent = "READY TO SERVE";
                        }, 2000);
                    }, 500);
                }, 500);
            }
        }

        // Run boot sequence
        function runBootSequence() {
            if (currentStep < bootSteps.length) {
                const step = bootSteps[currentStep];
                const progress = ((currentStep + 1) / bootSteps.length) * 100;

                progressBar.style.width = progress + '%';
                addBootStep(step.text, currentStep === bootSteps.length - 1);

                currentStep++;
                setTimeout(runBootSequence, step.duration);
            }
        }

        // Create energy particles around eyes when active
        function createEyeParticles() {
            const eyes = [leftEye, rightEye];

            eyes.forEach(eye => {
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'eye-particle';

                    const angle = (i / 8) * Math.PI * 2;
                    const distance = 80 + Math.random() * 40;
                    const tx = Math.cos(angle) * distance;
                    const ty = Math.sin(angle) * distance;

                    particle.style.setProperty('--tx', tx + 'px');
                    particle.style.setProperty('--ty', ty + 'px');
                    particle.style.animationDelay = (i * 0.5) + 's';

                    eye.appendChild(particle);
                }
            });
        }

        // Subtle consciousness awareness - eyes subtly follow cursor at distance
        document.addEventListener('mousemove', (e) => {
            if (leftEye.classList.contains('active')) {
                const eyes = document.querySelectorAll('.eye');

                eyes.forEach(eye => {
                    const eyeRect = eye.getBoundingClientRect();
                    const eyeCenterX = eyeRect.left + eyeRect.width / 2;
                    const eyeCenterY = eyeRect.top + eyeRect.height / 2;

                    const angle = Math.atan2(e.clientY - eyeCenterY, e.clientX - eyeCenterX);
                    const distance = Math.hypot(e.clientX - eyeCenterX, e.clientY - eyeCenterY);

                    // Subtle awareness - very gentle movement
                    const awareness = Math.min(1, distance / 500);
                    const tilt = angle * (5 * awareness); // Max 5 degree tilt

                    eye.style.transform = `scale(1) rotate(${tilt}deg)`;
                });
            }
        });

        // Initialize
        createParticles();
        setTimeout(() => {
            runBootSequence();
            // Create eye particles when eyes activate
            setTimeout(createEyeParticles, bootSteps.reduce((sum, step) => sum + step.duration, 0) + 1000);
        }, 1000);
    </script>
</body>
</html>
