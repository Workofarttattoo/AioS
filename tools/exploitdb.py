#!/usr/bin/env python3
"""
ExploitDB Search Tool - Educational security research tool
Copyright (c) 2025 Joshua Hendricks Cole (DBA: Corporation of Light). All Rights Reserved. PATENT PENDING.

Educational tool for searching and researching known vulnerabilities from Exploit-DB.
FOR AUTHORIZED SECURITY RESEARCH AND EDUCATIONAL PURPOSES ONLY.
"""

import sys
import json
import argparse
from typing import List, Dict, Optional
import re

EXPLOITS_DATABASE = [
    {
        "edb_id": "EDB-51337",
        "title": "Apache Log4j2 2.14.1 - Remote Code Execution (RCE)",
        "author": "Exploit-DB Team",
        "type": "remote",
        "platform": "multiple",
        "date": "2021-12-10",
        "cve": ["CVE-2021-44228"],
        "verified": True,
        "description": "Apache Log4j2 <=2.14.1 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints.",
        "path": "webapps/51337.py"
    },
    {
        "edb_id": "EDB-50752",
        "title": "Microsoft Exchange Server - ProxyShell RCE",
        "author": "Orange Tsai",
        "type": "remote",
        "platform": "windows",
        "date": "2021-08-13",
        "cve": ["CVE-2021-34473", "CVE-2021-34523", "CVE-2021-31207"],
        "verified": True,
        "description": "ProxyShell is the chain of CVE-2021-34473, CVE-2021-34523, and CVE-2021-31207 for Microsoft Exchange Server RCE.",
        "path": "webapps/50752.txt"
    },
    {
        "edb_id": "EDB-49654",
        "title": "Microsoft Windows - EternalBlue SMB Remote Code Execution",
        "author": "Equation Group / Shadow Brokers",
        "type": "remote",
        "platform": "windows",
        "date": "2017-05-12",
        "cve": ["CVE-2017-0144"],
        "verified": True,
        "description": "MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption for Windows 7/2008/2012",
        "path": "windows/49654.py"
    },
    {
        "edb_id": "EDB-51234",
        "title": "Drupal 7.x / 8.x - Remote Code Execution (Drupalgeddon2)",
        "author": "Vitalii Rudnykh",
        "type": "webapps",
        "platform": "php",
        "date": "2018-04-12",
        "cve": ["CVE-2018-7600"],
        "verified": True,
        "description": "Drupal before 7.58, 8.x before 8.3.9, 8.4.x before 8.4.6, and 8.5.x before 8.5.1 allows remote attackers to execute arbitrary code.",
        "path": "webapps/51234.txt"
    },
    {
        "edb_id": "EDB-48506",
        "title": "Oracle WebLogic Server - Deserialization Remote Code Execution",
        "author": "Exploit-DB",
        "type": "remote",
        "platform": "multiple",
        "date": "2020-04-26",
        "cve": ["CVE-2020-2883"],
        "verified": True,
        "description": "Oracle WebLogic Server allows unauthenticated attackers with network access via IIOP to compromise Oracle WebLogic Server.",
        "path": "webapps/48506.txt"
    },
    {
        "edb_id": "EDB-50961",
        "title": "Windows Print Spooler - PrintNightmare RCE",
        "author": "Cube0x0",
        "type": "local",
        "platform": "windows",
        "date": "2021-07-01",
        "cve": ["CVE-2021-34527", "CVE-2021-1675"],
        "verified": True,
        "description": "Windows Print Spooler Remote Code Execution Vulnerability allows attackers to execute arbitrary code with SYSTEM privileges.",
        "path": "windows/50961.py"
    },
    {
        "edb_id": "EDB-49942",
        "title": "Apache Struts2 - Remote Code Execution",
        "author": "Man Yue Mo",
        "type": "webapps",
        "platform": "multiple",
        "date": "2021-04-15",
        "cve": ["CVE-2021-31805"],
        "verified": True,
        "description": "Apache Struts 2.0.0 - 2.5.29 forced OGNL evaluation may lead to remote code execution.",
        "path": "webapps/49942.py"
    },
    {
        "edb_id": "EDB-47887",
        "title": "BlueKeep RDP Remote Windows Kernel Use After Free",
        "author": "Metasploit",
        "type": "remote",
        "platform": "windows",
        "date": "2019-09-06",
        "cve": ["CVE-2019-0708"],
        "verified": True,
        "description": "Remote Desktop Services on Windows allows remote code execution via specially crafted requests.",
        "path": "windows/47887.rb"
    }
]


def search_exploits(query: str, platform: str = "all", exploit_type: str = "all") -> List[Dict]:
    """Search the exploit database"""
    results = []
    query_lower = query.lower()

    for exploit in EXPLOITS_DATABASE:
        # Platform filter
        if platform != "all" and exploit["platform"] != platform:
            continue

        # Type filter
        if exploit_type != "all" and exploit["type"] != exploit_type:
            continue

        # Search in title, description, CVE, or EDB ID
        if (query_lower in exploit["title"].lower() or
            query_lower in exploit["description"].lower() or
            any(query_lower in cve.lower() for cve in exploit["cve"]) or
            query_lower in exploit["edb_id"].lower()):
            results.append(exploit)

    return results


def display_exploit(exploit: Dict, detailed: bool = False):
    """Display exploit information"""
    print(f"\n{'='*80}")
    print(f"EDB-ID: {exploit['edb_id']}")
    print(f"Title: {exploit['title']}")
    print(f"Author: {exploit['author']}")
    print(f"Date: {exploit['date']}")
    print(f"Type: {exploit['type']}")
    print(f"Platform: {exploit['platform']}")
    print(f"Verified: {'Yes' if exploit['verified'] else 'No'}")

    if exploit['cve']:
        print(f"CVE: {', '.join(exploit['cve'])}")

    if detailed:
        print(f"\nDescription:")
        print(f"  {exploit['description']}")
        print(f"\nPath: {exploit['path']}")

    print('='*80)


def health_check() -> Dict:
    """Health check for the tool"""
    import time
    start = time.time()

    status = "ok"
    summary = f"ExploitDB database loaded with {len(EXPLOITS_DATABASE)} exploits"

    details = {
        "total_exploits": len(EXPLOITS_DATABASE),
        "platforms": list(set(e["platform"] for e in EXPLOITS_DATABASE)),
        "types": list(set(e["type"] for e in EXPLOITS_DATABASE)),
        "verified_count": sum(1 for e in EXPLOITS_DATABASE if e["verified"])
    }

    latency = (time.time() - start) * 1000
    details["latency_ms"] = round(latency, 2)

    return {
        "tool": "exploitdb",
        "status": status,
        "summary": summary,
        "details": details
    }


def main(argv=None):
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="ExploitDB Search Tool - Educational security research",
        epilog="FOR AUTHORIZED SECURITY RESEARCH AND EDUCATIONAL PURPOSES ONLY"
    )

    parser.add_argument("query", nargs="?", help="Search query (CVE, keyword, etc.)")
    parser.add_argument("--platform", choices=["all", "windows", "linux", "multiple", "php"],
                       default="all", help="Filter by platform")
    parser.add_argument("--type", choices=["all", "remote", "local", "webapps", "dos"],
                       default="all", help="Filter by exploit type")
    parser.add_argument("--detailed", "-d", action="store_true", help="Show detailed information")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("--health", action="store_true", help="Run health check")

    args = parser.parse_args(argv)

    # Health check
    if args.health:
        health = health_check()
        if args.json:
            print(json.dumps(health, indent=2))
        else:
            print(f"[{health['status'].upper()}] {health['summary']}")
            print(f"Details: {json.dumps(health['details'], indent=2)}")
        return 0

    # Require query
    if not args.query:
        parser.print_help()
        return 1

    # Educational disclaimer
    if not args.json:
        print("\n" + "="*80)
        print("EDUCATIONAL SECURITY RESEARCH TOOL")
        print("FOR AUTHORIZED TESTING AND LEARNING PURPOSES ONLY")
        print("Unauthorized use is illegal and unethical")
        print("="*80 + "\n")

    # Search
    results = search_exploits(args.query, args.platform, args.type)

    if args.json:
        print(json.dumps(results, indent=2))
    else:
        if not results:
            print(f"No exploits found for query: {args.query}")
            return 0

        print(f"Found {len(results)} exploit(s):\n")

        for exploit in results:
            display_exploit(exploit, args.detailed)

    return 0


if __name__ == "__main__":
    sys.exit(main())
