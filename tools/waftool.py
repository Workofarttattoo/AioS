#!/usr/bin/env python3
"""
Copyright (c) 2025 Joshua Hendricks Cole (DBA: Corporation of Light). All Rights Reserved. PATENT PENDING.

WAFTool - Web Application Firewall Detection & Bypass Assistant
Detects WAF/IDS/IPS solutions protecting web applications and suggests bypass techniques.
"""

import sys
import json
import argparse
import time
import requests
from urllib.parse import urlparse
from typing import Dict, List, Any, Optional
import re

# === IP DETECTION FIX ===
_original_json_dumps = None
try:
    import json
    import ipaddress
    import re
    _original_json_dumps = json.dumps
    
    def enhance_ip_data(obj):
        """Recursively enhance IP addresses in data structures"""
        if isinstance(obj, str):
            # Check if this is an IP
            if re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', obj):
                try:
                    ip = ipaddress.ip_address(obj)
                    parts = []
                    if ip.is_private:
                        parts.append("Private IP (RFC1918)")
                    if str(ip) in ["8.8.8.8", "8.8.4.4"]:
                        parts.append("Google DNS")
                    elif str(ip) in ["1.1.1.1", "1.0.0.1"]:
                        parts.append("Cloudflare DNS")
                    if parts:
                        return f"{obj} ({', '.join(parts)})"
                except:
                    pass
            return obj
        elif isinstance(obj, dict):
            return {k: enhance_ip_data(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [enhance_ip_data(item) for item in obj]
        else:
            return obj
    
    def enhanced_json_dumps(obj, **kwargs):
        """Enhanced json.dumps that adds IP detection"""
        enhanced_obj = enhance_ip_data(obj)
        return _original_json_dumps(enhanced_obj, **kwargs)
    
    # Monkey patch json.dumps
    json.dumps = enhanced_json_dumps
except ImportError:
    pass
# === END IP DETECTION FIX ===




WAF_SIGNATURES = {
    "Cloudflare": {
        "headers": ["cf-ray", "cf-cache-status", "__cfduid"],
        "cookies": ["__cfduid", "__cflb"],
        "content": ["cloudflare", "cf-error-details"],
        "response_codes": [403, 429, 503],
        "bypasses": [
            "Use IP rotation via residential proxies",
            "Modify User-Agent headers to mimic legitimate traffic",
            "Fragment payloads across multiple requests",
            "Use encoding chains (base64, hex, URL)",
            "Leverage Cloudflare's cache behavior with cache poisoning",
            "Time-based evasion to avoid rate limits"
        ]
    },
    "AWS WAF": {
        "headers": ["x-amzn-requestid", "x-amz-cf-id", "x-amzn-trace-id"],
        "cookies": ["awselb", "awsalb"],
        "content": ["Access Denied"],
        "response_codes": [403],
        "bypasses": [
            "Case manipulation in payloads",
            "Null byte injection (%00)",
            "UTF-8 overlong encoding",
            "HTTP request smuggling (CL.TE or TE.CL)",
            "Parameter pollution with duplicate keys",
            "Host header injection"
        ]
    },
    "Akamai": {
        "headers": ["akamai-origin-hop", "x-akamai-request-id", "akamai-grn"],
        "cookies": ["ak_bmsc"],
        "content": ["Reference #", "Access Denied"],
        "response_codes": [403],
        "bypasses": [
            "HTTP header pollution with mixed case",
            "Path confusion with %2f vs /",
            "Parameter pollution with encoded delimiters",
            "Chunked transfer encoding manipulation",
            "Cache key poisoning via headers",
            "Session puzzle solving bypass"
        ]
    },
    "Imperva (Incapsula)": {
        "headers": ["x-cdn", "x-iinfo"],
        "cookies": ["incap_ses", "visid_incap"],
        "content": ["incapsula", "Request unsuccessful"],
        "response_codes": [403],
        "bypasses": [
            "SQL comment obfuscation (/**/ or --+)",
            "Unicode normalization attacks",
            "HTTP parameter pollution (multiple params same name)",
            "Whitespace manipulation in SQL/XSS",
            "Protocol-level smuggling",
            "Session fixation to bypass CAPTCHA"
        ]
    },
    "F5 BIG-IP ASM": {
        "headers": ["x-wa-info", "bigipserver", "x-cnection"],
        "cookies": ["TS", "BIGipServer"],
        "content": ["The requested URL was rejected"],
        "response_codes": [403],
        "bypasses": [
            "Polyglot payloads combining XSS+SQLi",
            "Protocol-level evasion (HTTP/0.9)",
            "HTTP request smuggling",
            "Parameter cloaking with encoding",
            "Session token manipulation",
            "Cookie injection bypass"
        ]
    },
    "ModSecurity": {
        "headers": ["server"],
        "cookies": [],
        "content": ["mod_security", "NOYB", "This error was generated by Mod_Security"],
        "response_codes": [403, 406, 501],
        "bypasses": [
            "Regex bypass with newlines and special chars",
            "Case manipulation (SeLeCt vs SELECT)",
            "Comment injection in SQL (/**/ or --)",
            "Encoding chains (double URL encoding)",
            "HTTP verb tampering (PUT instead of POST)",
            "Content-Type confusion attacks"
        ]
    },
    "Barracuda": {
        "headers": ["barra_counter_session", "barracuda"],
        "cookies": ["barra_counter_session"],
        "content": ["barracuda"],
        "response_codes": [403],
        "bypasses": [
            "SSL/TLS version manipulation",
            "Request method tampering (OPTIONS, TRACE)",
            "Content-Type confusion (multipart/form-data)",
            "Rate limit evasion with request spacing",
            "Path parameter injection",
            "Header injection attacks"
        ]
    },
    "Sucuri": {
        "headers": ["x-sucuri-id", "x-sucuri-cache"],
        "cookies": [],
        "content": ["sucuri", "Access Denied - Sucuri"],
        "response_codes": [403],
        "bypasses": [
            "Cache poisoning via headers",
            "Time-based evasion (slow requests)",
            "Geographic IP variation",
            "User-Agent rotation per request",
            "Referer header manipulation",
            "X-Forwarded-For spoofing"
        ]
    },
    "Wordfence": {
        "headers": [],
        "cookies": ["wfvt_", "wordfence"],
        "content": ["wordfence", "generated by Wordfence"],
        "response_codes": [403, 503],
        "bypasses": [
            "Known WordPress plugin vulnerabilities",
            "IP whitelisting abuse via X-Forwarded-For",
            "Authentication bypass via session manipulation",
            "Rate limit circumvention with distributed IPs",
            "Cookie poisoning attacks",
            "XML-RPC brute force alternative paths"
        ]
    },
    "Fortinet FortiWeb": {
        "headers": ["fortigate", "fortiweb"],
        "cookies": ["FORTIWAFSID"],
        "content": [],
        "response_codes": [403],
        "bypasses": [
            "HTTP parameter pollution",
            "Path normalization attacks",
            "Verb tampering (HEAD vs GET)",
            "Double encoding payloads",
            "Protocol downgrade (HTTP/1.0)",
            "Custom header injection"
        ]
    }
}

TEST_PAYLOADS = [
    {
        "name": "XSS Basic",
        "payload": "<script>alert(1)</script>",
        "description": "Basic XSS payload to trigger WAF",
        "type": "xss"
    },
    {
        "name": "XSS Advanced",
        "payload": "<img src=x onerror=alert(1)>",
        "description": "Event-based XSS",
        "type": "xss"
    },
    {
        "name": "SQL Injection",
        "payload": "' OR '1'='1' --",
        "description": "Classic SQL injection pattern",
        "type": "sqli"
    },
    {
        "name": "SQL Union",
        "payload": "' UNION SELECT NULL,NULL,NULL--",
        "description": "UNION-based SQL injection",
        "type": "sqli"
    },
    {
        "name": "Path Traversal",
        "payload": "../../etc/passwd",
        "description": "Directory traversal attempt",
        "type": "lfi"
    },
    {
        "name": "Command Injection",
        "payload": "; cat /etc/passwd",
        "description": "OS command injection",
        "type": "rce"
    },
    {
        "name": "XXE Injection",
        "payload": '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>',
        "description": "XML external entity",
        "type": "xxe"
    },
    {
        "name": "LDAP Injection",
        "payload": "*)(uid=*))(|(uid=*",
        "description": "LDAP query manipulation",
        "type": "ldap"
    }
]


class WAFDetector:
    """Web Application Firewall detection engine"""

    def __init__(self, target_url: str, timeout: int = 10, follow_redirects: bool = True):
        self.target_url = target_url
        self.timeout = timeout
        self.follow_redirects = follow_redirects
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        })
        self.results = []

    def detect(self) -> Dict[str, Any]:
        """Main detection routine"""
        print(f"[*] Analyzing target: {self.target_url}")

        # Phase 1: Baseline request
        baseline = self._get_baseline()
        if not baseline:
            return {"error": "Failed to establish baseline connection", "results": []}

        # Phase 2: Header analysis
        print("[*] Phase 1: Analyzing response headers...")
        header_detections = self._analyze_headers(baseline.get('headers', {}))

        # Phase 3: Cookie analysis
        print("[*] Phase 2: Analyzing cookies...")
        cookie_detections = self._analyze_cookies(baseline.get('cookies', {}))

        # Phase 4: Content analysis
        print("[*] Phase 3: Analyzing response content...")
        content_detections = self._analyze_content(baseline.get('content', ''))

        # Phase 5: Payload testing
        print("[*] Phase 4: Testing attack payloads...")
        payload_detections = self._test_payloads()

        # Combine and score detections
        all_detections = self._combine_detections(
            header_detections,
            cookie_detections,
            content_detections,
            payload_detections
        )

        return {
            "target": self.target_url,
            "baseline": baseline,
            "results": all_detections,
            "timestamp": time.time()
        }

    def _get_baseline(self) -> Optional[Dict[str, Any]]:
        """Establish baseline connection"""
        try:
            start_time = time.time()
            resp = self.session.get(
                self.target_url,
                timeout=self.timeout,
                allow_redirects=self.follow_redirects,
                verify=False
            )
            response_time = int((time.time() - start_time) * 1000)

            return {
                "status_code": resp.status_code,
                "headers": dict(resp.headers),
                "cookies": dict(resp.cookies),
                "content": resp.text[:10000],  # First 10KB
                "response_time_ms": response_time
            }
        except Exception as e:
            print(f"[!] Baseline request failed: {e}")
            return None

    def _analyze_headers(self, headers: Dict[str, str]) -> Dict[str, List[str]]:
        """Analyze response headers for WAF signatures"""
        detections = {}

        for waf_name, signatures in WAF_SIGNATURES.items():
            matches = []
            for sig_header in signatures['headers']:
                for header_key in headers.keys():
                    if sig_header.lower() in header_key.lower():
                        matches.append(f"Header: {header_key}")

            if matches:
                detections[waf_name] = matches

        return detections

    def _analyze_cookies(self, cookies: Dict[str, str]) -> Dict[str, List[str]]:
        """Analyze cookies for WAF signatures"""
        detections = {}

        for waf_name, signatures in WAF_SIGNATURES.items():
            matches = []
            for sig_cookie in signatures['cookies']:
                for cookie_name in cookies.keys():
                    if sig_cookie.lower() in cookie_name.lower():
                        matches.append(f"Cookie: {cookie_name}")

            if matches:
                detections[waf_name] = matches

        return detections

    def _analyze_content(self, content: str) -> Dict[str, List[str]]:
        """Analyze response content for WAF signatures"""
        detections = {}

        for waf_name, signatures in WAF_SIGNATURES.items():
            matches = []
            for sig_content in signatures['content']:
                if sig_content.lower() in content.lower():
                    matches.append(f"Content: '{sig_content}'")

            if matches:
                detections[waf_name] = matches

        return detections

    def _test_payloads(self) -> Dict[str, List[str]]:
        """Test attack payloads to trigger WAF"""
        detections = {}

        for payload_test in TEST_PAYLOADS[:4]:  # Test subset to avoid triggering real blocks
            try:
                # Test as query parameter
                test_url = f"{self.target_url}?test={payload_test['payload']}"
                resp = self.session.get(test_url, timeout=5, verify=False)

                # Check for WAF response codes
                for waf_name, signatures in WAF_SIGNATURES.items():
                    if resp.status_code in signatures['response_codes']:
                        if waf_name not in detections:
                            detections[waf_name] = []
                        detections[waf_name].append(f"Blocked {payload_test['type']} payload (HTTP {resp.status_code})")

                time.sleep(0.5)  # Rate limiting

            except Exception as e:
                continue

        return detections

    def _combine_detections(self, *detection_sets) -> List[Dict[str, Any]]:
        """Combine and score all detections"""
        combined = {}

        for detection_set in detection_sets:
            for waf_name, indicators in detection_set.items():
                if waf_name not in combined:
                    combined[waf_name] = []
                combined[waf_name].extend(indicators)

        # Build final results with confidence scores
        results = []
        for waf_name, indicators in combined.items():
            confidence = min(95, 30 + (len(indicators) * 15))
            results.append({
                "waf": waf_name,
                "confidence": confidence,
                "indicators": list(set(indicators)),  # Remove duplicates
                "bypasses": WAF_SIGNATURES[waf_name]['bypasses']
            })

        # Sort by confidence
        results.sort(key=lambda x: x['confidence'], reverse=True)
        return results


def main(argv=None):
    """CLI entrypoint"""
    parser = argparse.ArgumentParser(
        description="WAFTool - Web Application Firewall Detection & Bypass Assistant"
    )
    parser.add_argument('target', nargs='?', help='Target URL (e.g., https://example.com)')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds')
    parser.add_argument('--no-follow', action='store_true', help='Do not follow redirects')
    parser.add_argument('--json', action='store_true', help='Output results as JSON')
    parser.add_argument('--gui', action='store_true', help='Launch web-based GUI')
    parser.add_argument('--port', type=int, default=8086, help='GUI server port (default: 8086)')

    args = parser.parse_args(argv)

    if args.gui:
        launch_gui(args.port)
        return

    if not args.target:
        parser.print_help()
        print("\n[!] Error: Target URL is required")
        print("Example: python waftool.py https://example.com")
        return

    # Validate URL
    parsed = urlparse(args.target)
    if not parsed.scheme or not parsed.netloc:
        print("[!] Error: Invalid URL. Must include scheme (http:// or https://)")
        return

    # Run detection
    detector = WAFDetector(
        target_url=args.target,
        timeout=args.timeout,
        follow_redirects=not args.no_follow
    )

    results = detector.detect()

    if args.json:
        print(json.dumps(results, indent=2))
    else:
        print_results(results)


def print_results(results: Dict[str, Any]):
    """Print human-readable results"""
    print("\n" + "="*70)
    print("WAF DETECTION RESULTS")
    print("="*70)

    baseline = results.get('baseline', {})
    print(f"\n[+] Target: {results['target']}")
    print(f"[+] Status Code: {baseline.get('status_code', 'N/A')}")
    print(f"[+] Response Time: {baseline.get('response_time_ms', 'N/A')}ms")

    detections = results.get('results', [])

    if not detections:
        print("\n[✓] No WAF detected")
        print("[i] Target does not appear to be protected by a known WAF solution")
    else:
        print(f"\n[!] WAF DETECTED: {len(detections)} signature(s) found\n")

        for idx, detection in enumerate(detections, 1):
            print(f"{'─'*70}")
            print(f"Detection #{idx}: {detection['waf']}")
            print(f"{'─'*70}")
            print(f"Confidence: {detection['confidence']}%")

            print(f"\nIndicators ({len(detection['indicators'])}):")
            for indicator in detection['indicators']:
                print(f"  • {indicator}")

            print(f"\nBypass Techniques:")
            for idx_bypass, bypass in enumerate(detection['bypasses'], 1):
                print(f"  {idx_bypass}. {bypass}")
            print()


def launch_gui(port: int = 8086):
    """Launch web-based GUI"""
    from flask import Flask, render_template_string, request, jsonify

    app = Flask(__name__)

    @app.route('/')
    def index():
        return render_template_string(GUI_HTML)

    @app.route('/api/scan', methods=['POST'])
    def scan():
        data = request.json
        target_url = data.get('target')

        if not target_url:
            return jsonify({"error": "No target specified"}), 400

        try:
            detector = WAFDetector(target_url, timeout=10)
            results = detector.detect()
            return jsonify(results)
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    print(f"[*] Starting WAFTool GUI on http://127.0.0.1:{port}")
    print(f"[*] Press Ctrl+C to stop")
    app.run(host='0.0.0.0', port=port, debug=False)


GUI_HTML = """
<!DOCTYPE html>
<html>
<head>
    <title>WAFTool - WAF Detection & Bypass Assistant</title>
    <meta charset="utf-8">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0a;
            --bg-medium: #1a1a1a;
            --bg-light: #2a2a2a;
            --accent: #ff3366;
            --accent-hover: #ff5577;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
            --border: #333333;
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff3366;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a0a0a 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 2px solid var(--accent);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            color: var(--accent);
            text-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1em;
        }

        .scan-section {
            background: var(--bg-medium);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        input[type="text"] {
            flex: 1;
            padding: 15px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1em;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(255, 51, 102, 0.2);
        }

        .btn {
            padding: 15px 30px;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 150px;
        }

        .btn:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 51, 102, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .baseline {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .baseline h3 {
            color: var(--accent);
            margin-bottom: 15px;
        }

        .baseline-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .baseline-item {
            display: flex;
            flex-direction: column;
        }

        .baseline-label {
            color: var(--text-muted);
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .baseline-value {
            color: var(--success);
            font-weight: 600;
        }

        .headers-list {
            background: var(--bg-medium);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 200px;
            overflow-y: auto;
        }

        .header-line {
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .header-key {
            color: #66ccff;
        }

        .results-section {
            display: grid;
            gap: 20px;
        }

        .detection-card {
            background: var(--bg-medium);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 25px;
            transition: all 0.3s;
        }

        .detection-card:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 20px rgba(255, 51, 102, 0.2);
        }

        .detection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .waf-name {
            font-size: 1.5em;
            color: var(--accent);
            font-weight: 600;
        }

        .confidence-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .confidence-high {
            background: rgba(255, 51, 102, 0.2);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .confidence-medium {
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid var(--warning);
            color: var(--warning);
        }

        .confidence-low {
            background: rgba(255, 255, 0, 0.2);
            border: 1px solid #ffff00;
            color: #ffff00;
        }

        .indicators-section,
        .bypasses-section {
            margin-bottom: 20px;
        }

        .section-title {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .indicators-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .indicator-badge {
            padding: 6px 12px;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid var(--warning);
            border-radius: 4px;
            color: var(--warning);
            font-size: 0.85em;
        }

        .bypasses-list {
            list-style: none;
        }

        .bypass-item {
            padding: 10px;
            background: var(--bg-dark);
            border-left: 3px solid var(--success);
            border-radius: 4px;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .bypass-item::before {
            content: "✓ ";
            color: var(--success);
            font-weight: 600;
            margin-right: 8px;
        }

        .no-waf {
            text-align: center;
            padding: 60px 20px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--success);
            border-radius: 8px;
        }

        .no-waf h3 {
            color: var(--success);
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--accent);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🛡️ WAFTool</h1>
            <div class="subtitle">Web Application Firewall Detection & Bypass Assistant</div>
        </header>

        <div class="scan-section">
            <div class="input-group">
                <input type="text" id="target-url" placeholder="https://example.com" />
                <button class="btn" id="scan-btn" onclick="startScan()">Detect WAF</button>
            </div>
        </div>

        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <div style="color: var(--text-secondary);">Scanning target...</div>
        </div>

        <div id="baseline" class="baseline hidden">
            <h3>Response Analysis</h3>
            <div class="baseline-grid">
                <div class="baseline-item">
                    <div class="baseline-label">Status Code</div>
                    <div class="baseline-value" id="status-code">-</div>
                </div>
                <div class="baseline-item">
                    <div class="baseline-label">Response Time</div>
                    <div class="baseline-value" id="response-time">-</div>
                </div>
            </div>
            <div id="headers-container" class="hidden">
                <div class="baseline-label" style="margin-bottom: 10px;">Response Headers</div>
                <div class="headers-list" id="headers-list"></div>
            </div>
        </div>

        <div id="results" class="results-section"></div>
    </div>

    <script>
        async function startScan() {
            const targetUrl = document.getElementById('target-url').value.trim();
            if (!targetUrl) {
                alert('Please enter a target URL');
                return;
            }

            // Reset UI
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('baseline').classList.add('hidden');
            document.getElementById('results').innerHTML = '';
            document.getElementById('scan-btn').disabled = true;

            try {
                const response = await fetch('/api/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ target: targetUrl })
                });

                const data = await response.json();

                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }

                displayResults(data);
            } catch (error) {
                alert('Scan failed: ' + error.message);
            } finally {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('scan-btn').disabled = false;
            }
        }

        function displayResults(data) {
            // Show baseline
            const baseline = data.baseline || {};
            document.getElementById('status-code').textContent = baseline.status_code || 'N/A';
            document.getElementById('response-time').textContent = `${baseline.response_time_ms || 0}ms`;

            // Show headers
            if (baseline.headers) {
                const headersList = document.getElementById('headers-list');
                headersList.innerHTML = '';
                for (const [key, value] of Object.entries(baseline.headers)) {
                    const line = document.createElement('div');
                    line.className = 'header-line';
                    line.innerHTML = `<span class="header-key">${key}:</span> ${value}`;
                    headersList.appendChild(line);
                }
                document.getElementById('headers-container').classList.remove('hidden');
            }

            document.getElementById('baseline').classList.remove('hidden');

            // Show detections
            const resultsContainer = document.getElementById('results');
            const detections = data.results || [];

            if (detections.length === 0) {
                resultsContainer.innerHTML = `
                    <div class="no-waf">
                        <h3>✓ No WAF Detected</h3>
                        <p style="color: var(--text-secondary);">Target does not appear to be protected by a known WAF solution</p>
                    </div>
                `;
                return;
            }

            detections.forEach(detection => {
                const card = createDetectionCard(detection);
                resultsContainer.appendChild(card);
            });
        }

        function createDetectionCard(detection) {
            const card = document.createElement('div');
            card.className = 'detection-card';

            const confidenceClass = detection.confidence >= 80 ? 'confidence-high' :
                                   detection.confidence >= 60 ? 'confidence-medium' : 'confidence-low';

            card.innerHTML = `
                <div class="detection-header">
                    <div class="waf-name">🛡️ ${detection.waf}</div>
                    <div class="confidence-badge ${confidenceClass}">${detection.confidence}% Confidence</div>
                </div>

                <div class="indicators-section">
                    <div class="section-title">Detection Indicators</div>
                    <div class="indicators-list">
                        ${detection.indicators.map(ind => `<span class="indicator-badge">${ind}</span>`).join('')}
                    </div>
                </div>

                <div class="bypasses-section">
                    <div class="section-title">Bypass Techniques</div>
                    <ul class="bypasses-list">
                        ${detection.bypasses.map(bypass => `<li class="bypass-item">${bypass}</li>`).join('')}
                    </ul>
                </div>
            `;

            return card;
        }

        // Allow Enter key to trigger scan
        document.getElementById('target-url').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') startScan();
        });
    </script>
</body>
</html>
"""


def health_check() -> Dict[str, Any]:
    """Health check for SecurityAgent integration"""
    return {
        "tool": "waftool",
        "status": "ok",
        "summary": "WAF detection and bypass suggestion tool",
        "details": {
            "waf_signatures": len(WAF_SIGNATURES),
            "test_payloads": len(TEST_PAYLOADS),
            "features": [
                "Header analysis",
                "Cookie fingerprinting",
                "Content pattern matching",
                "Payload-based detection",
                "Bypass technique suggestions"
            ]
        }
    }


if __name__ == "__main__":
    import warnings
    warnings.filterwarnings('ignore', message='Unverified HTTPS request')
    main()
